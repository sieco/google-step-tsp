import sys
import math
import time
import csv
from tkinter import*

begin = time.time()

def read_data():
    with open('google-step-tsp/input_0.csv') as f:
        reader = csv.reader(f)
        header = next(reader) 
        buff = []
        for a in reader:
            buff.append((float(a[0]), float(a[1])))
        return buff

def distance(ps):
    size = len(ps)
    table = [[0]*size for _ in range(size)]
    for i in range(size):
        for j in range(size):
            if i != j:
                dx = ps[i][0] - ps[j][0]
                dy = ps[i][1] - ps[j][1]
                table[i][j] = math.sqrt(dx*dx + dy*dy)
    return table

def memorize(f):
    table = {}
    def func(*args):
        if not args in table:
            table[args] = f(*args)
        return table[args]
    return func

def tsp(p, v):
    if (1 << point_size) - 1 == v:
        return distance_table[p][0]
    else:
        return min([distance_table[p][x] + tsp(x, v | (1 << x)) for x in xrange(point_size) if not (v & (1 << x))])

tsp = memorize(tsp)

def tsp_dp(size):
    size1 = size - 1
    table = [None] * (1 << size1)
    table[(1 << size1) - 1] = [distance_table[i][0] for i in xrange(1, size)]
    for v in xrange((1 << size1) - 2, 0, -1):
        tmp = [1e300] * size1
        for i in xrange(size1):
            if (1 << i) & v:
                tmp[i] = min([distance_table[i+1][j+1] + table[v | (1 << j)][j] for j in xrange(size1) if not (1 << j) & v])
        table[v] = tmp
    return min([distance_table[i+1][0] + table[1 << i][i] for i in xrange(size1)])

def min0(ary):
    v = (1e300, None)
    for x in ary:
        if v[0] > x[0]: v = x
    return v

point_table = read_data()
point_size = len(point_table)
distance_table = distance(point_table)

end = time.time()
min_len, min_path = input_0.csv(point_size)

print (min_len)
print (end - begin)

def draw_path(path):
    x0, y0 = path[0]
    for i in xrange(1, len(path)):
        x1, y1 = path[i]
        c0_create_line(x0, y0. path[0][0], path[0][1])
        for x,y in path:
            c0.create_oval(x-4, y-4, x+4, y+4, fill = "green")

max_x = max(map(lambda x:x[0], point_table)) + 20
max_y = max(map(lambda x:x[1], poiny_table)) + 20

root = tk()
c0 = Canvas(root,width = max_x, height = max_y, bg = "white")
c0.pack()
draw_path(map(lambda x: point_table[x], min_path))

root.mainloop()


    
